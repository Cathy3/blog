---
title: python刷leetcode贪心算法
date: 2019-07-4
categories: 
	-   Algorithm
tags:  
        -   python
        -   LeetCode
        -   贪心算法
mathjax: true
---

-   45. 跳跃游戏 II
-   55. 跳跃游戏
-   402. 移掉K位数字

<!-- more -->

**贪心算法**就是每次都贪心地选择当前最好的那个(局部最优解)，不去考虑以后的情况，而且选择了就不能够“反悔”了，如果原问题满足贪心选择性质和最优子结构，那么最后得到的解就是最优解。

每一步的最优解一定包含上一步的最优解。

区别于其他算法：

-   动态规划：每次都是综合所有子问题的解得到当前的最优解(全局最优解)，而不是贪心地选择；
-   回溯法：尝试选择一条路，如果选择错了的话可以“反悔”，也就是回过头来重新选择其他的试试。

# 45. 跳跃游戏 II
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
说明:

假设你总是可以到达数组的最后一个位置。

## 方法：贪心算法
我们每次贪心的找在自己当前能到达的几个位置里面，跳到哪个位置的时候，在下一步能跳的最远。然后，我们当前步就跳到这个位置上去，所以我们在这一步的跳跃时，给下一步留下了最好的结果。

所以，使用一个cur表示当前步能到达的最远位置，使用pre表示上一次能到达的最远位置。所以，我们应该遍历在上一步的覆盖范围内，当前能跳的最远位置来更新cur。一个节省计算资源的方式是，保存以前已经检查了的位置为Pos，这样每次检查的范围是pos~pre。

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        cur = 0
        pre = 0
        jump = 0  # 需要跳跃多少次
        pos = 0   # 当前的位置
        while cur < len(nums)-1:
            jump +=1  #一轮跳跃一步
            pre = cur # 上一步能跨越最远的位置给了pre
            while pos <= pre:
                cur = max(cur,pos+nums[pos]) # cur是当前范围内能跨越最远的位置
                pos += 1
        return jump
```

# 55. 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:
```
输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
```
示例 2:
```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

## 方法：贪心算法
用一个变量reach保存当前能到达的最后位置索引，那么在每个位置的时候判断这个位置能不能到达，即位置的索引大于了reach说明前面无论怎么走也走不到这个位置，就返回False

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        reach = 0
        for i, num in enumerate(nums):
            if i>reach:
                return False
            reach = max(reach, i+num)
        return True
```



# 402. 移掉K位数字
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:

1.   num 的长度小于 10002 且 ≥ k。
2.   num 不会包含任何前导零。

示例 1 :
```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```

示例 2 :
```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

示例 3 :
```
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

## 方法：栈

遍历数字字符串，当当前的字符比栈最后的字符小的时候，说明要把栈的最后的这个字符删除掉。然后用现在的字符进行替换，是不是数字比以前的那种情况更小了？所以同样的道理，做一个while循环！

最后，如果K还没用完，那要删除哪里的字符呢？毋庸置疑肯定是最后的字符，因为前面的字符都是小字符。

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        if len(num) == k:
            return '0'
        stack = []
        for n in num:
            # while每轮循环删除局部最大值
            while stack and k and int(stack[-1]) > int(n):
                stack.pop() # 删除栈中最大的一个值
                k -= 1
            stack.append(n) # 栈里的值由小到大,新加入栈的值最大
            
        while k: # k还有剩余
            stack.pop()
            k -= 1
        
        if not stack:
            return '0'
        
        return str(int(''.join(stack)))
```
