---
title: 牛客小白月赛16题解
date: 2019-07-13
categories: 
		- Algorithm
tags:  
        - python
        - 牛客
mathjax: true
---
本文来自牛客网的[小白月赛16](https://ac.nowcoder.com/acm/contest/949#question)的题

-   A	小石的签到题
-   B	小雨的三角形
-   C	小石的海岛之旅
-   D	小阳买水果
-   E	小雨的矩阵
-   F	小石的妹子
-   G	小石的图形
-   H	小阳的贝壳
-   I	石头剪刀布	
-   J	小雨坐地铁

<!-- more -->

# A-小石的签到题
[牛客小白月赛16-A小石的签到题](https://ac.nowcoder.com/acm/contest/949/A)


小石和小阳玩游戏，一共有 $n$ 个数，分别为 $1∼n$ 。两人轮流取数，小石先手。对于每轮取数，都必须选择剩下数中的任意一个数 $x$，同时还要取走 $x,⌊\frac{x}{2}⌋,⌊\frac{⌊\frac{x}{2}⌋}{2}⌋…$ 如果某个数不存在，就停止取数（不能一个数都不取）。谁取走最后一个数，谁就输了。小石想知道自己能否获胜。 如果小石能赢，输出 “Shi”，否则输出 "Yang”（均不输出引号）。


输入描述:共一行，输入一个数 $n$ 。

输出描述:共一行，输出 "Shi" 或 "Yang"（不输出引号）。

示例1: 输入1，输出 Yang

说明：小石只能取走 1，小阳赢。

示例2 输入2，输出Shi

说明：若小石取走 1，则小阳只能取走 2，小石赢。

备注:$1 ≤n≤10^3$

## 方法：博弈论SG
我们发现当 $n>1$ 时先手（小石）总是赢。

如何证明：一开始有 $1∼n$ , $n$ 个数，假设先手必败，那么先手选 
1，后手就进入了必败状态。

所以假设错误，那么先手就不是必败，先手一定有一种方式能赢。

```python
n = int(input())
if n==1:
    print('Yang')
else:
    print('Shi')
```

# B-小雨的三角形
[牛客小白月赛16-B小雨的三角形](https://ac.nowcoder.com/acm/contest/949/B)

小雨手上有一个填满了数字的三角形。这个三角形一共有 $n$ 层，其中第 $i$ 层共有 $i$ 个数，且第 1 个数和第 $i$ 个数均为 $i$ 。其余的数中，第 $j$ 个数是上一层中第 $j−1$ 个数和第 $j$ 个数的和。小雨想知道这个三角形第 $x$ 层到第 $y$ 层所有数的和，一共有 $m$ 个询问。 


输入描述:

第一行两个正整数 $n,m$，表示这个三角形的层数和询问个数。

接下来 $m$ 行，每行两个正整数 $x,y$，表示一次询问。

输出描述:
输出共 $m$ 行，每行两个整数，表示一组询问的答案，对 $10^9+7$ 取模。

示例1
```
输入
5 3
1 2
1 5
3 5

输出
5
83
78

说明
画出这个三角形：
1
2 2
3 4 3
4 7 7 4
5 11 14 11 5
```
第1-2层的和为 $1+2+2 = 5$

第1-5层的和为 $1+2+2+3+4+3+4+7+7+4+5+11+14+11+5 = 83$

第3-5层的和为 $3+4+3+4+7+7+4+5+11+14+11+5 = 78$

备注：$1 ≤n≤10^3, 1≤x≤y≤n$

## 方法：数学
数据范围给的很小，可以 $O(n^2)$ 暴力构造三角形，预处理出每一行的总和，每个询问把 $x∼y$ 行的和加起来即可（若预处理出第 $1∼i$ 行的和，则可以做到 $O(1)$ 查询）。

更快的做法？每一行的和其实是有规律的，分别为 $1,4,10,22,46,94⋯$，除了第 1 行的和为 1 外，第 $i$ 行的和为 $6⋅2i−2−2$，那么第 $1∼i (i>1)$ 行的和为

$$
1+6⋅20−2+6⋅22−2+6⋅23−2+⋯+6⋅2i−2−2\\
=1+6⋅(2i−1−1)−2⋅(i−1)\\
=6⋅2i−1−2⋅i−3\\
$$

所以第 $x∼y$ 行的和就能用前缀和计算出 $3(2^{y}-2^{x-1}) + 2(x-y)-2$，注意特判 $x=1,x=2,y=1$ 的情况，这样就能够每次 $O(log⁡n)$ 查询。


```python
n,m = map(int, input().split(' '))
M = int(1e9+7)
for _ in range(m):
    x, y = map(int, input().split(' '))
    print((3*(2**y - 2**(x-1)) + 2*(x-y) - 2)%M)
```


# C-小石的海岛之旅
[牛客小白月赛16-C小石的海盗之旅](https://ac.nowcoder.com/acm/contest/949/C)


暑假到了，小石和小雨到海岛上玩。
从水平方向看海岛可以看成 $n$ 个小块，每一个小块都有一个高度 $h_i$，
水位一开始为 0，随着水位的上升，海岛分成了若干块。现在有 $m$ 个询问，求当水位为 $a_i$ 时，海岛会分成多少块。

输入描述:

第一行输入两个正整数 n,m，分别表示海岛小块个数和询问个数。

第二行输入 n 个整数 $h_i$，表示每一块的高度。

第三行输入 m个整数 ai，表示每一个询问，保证输入的 ai 单调递增。

输出描述:
共 m 行，分别对应 m 个询问的答案。

示例1
```
输入
7 3
1 2 3 1 2 1 3
1 2 3

输出
3
2
0
说明
当水位高度为 1 时，岛屿被分成 3 块，2 3；2；3

当水位高度为 2 时，岛屿被分成 2 块：3；3 。

当水位高度为 3 时，岛屿全部被淹没，剩余 0 块 。
```

## 方法：枚举

```python
n, m = map(int, input().split())
h = list(map(int, input().split()))
a = list(map(int, input().split()))
for a_i in a:
    ans = int(h[0] > a_i) #第一块高于水位是1，低于水位是0
    for j in range(1, len(h)):
        if h[j]>a_i and h[j-1]<=a_i: 
            ans += 1
    print(ans)
```

# D-小阳买水果
[牛客小白月赛16-D小阳买水果](https://ac.nowcoder.com/acm/contest/949/D)

水果店里有 $n$ 个水果排成一列。店长要求顾客只能买一段连续的水果。

小阳对每个水果都有一个喜爱程度 $a_i$，最终的满意度为他买到的水果的喜欢程度之和。

如果和为正（不管是正多少，只要大于 0 即可），他就满意了。

小阳想知道在他满意的条件下最多能买多少个水果。
你能帮帮他吗？

输入描述:

第一行输入一个正整数 n，表示水果总数。

第二行输入 n 个整数 $a_i$，表示小阳对每个水果的喜爱程度。

输出描述: 一行一个整数表示结果。

示例1
```
输入
5
0 0 -7 -6 1
输出
1
```

## 方法：和大于0的最长连续子序列
python超时很难通过，用C++

遍历i从1-n，前i个数中，找到那个比s小的最左边位置，设为r, r-i之间的子串就是最长子串。

所有满足条件的子串的0~右边界的和 $>$ 0~左边界的和，所以要找到那个最左边的左边界。


```c++
#include<bits/stdc++.h>
using namespace std;
int a[2000061],s,x,ans;
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
    {
        scanf("%d",&x);
        s+=x;
        a[i]=min(a[i-1],s);
        int l=0,r=i-1;
        while(l<=r)
        {
            int mid=(l+r)/2;
            if(a[mid]<s)
            {
                r=mid-1;
            }
            else
                l=mid+1;
        }
        if(r!=-2)
        {
            ans=max(ans,i-r-1);
        }
    }
    cout<<ans<<endl;
}
```


# E-小雨的矩阵
[牛客小白月赛16-E小雨的矩阵](https://ac.nowcoder.com/acm/contest/949/E)

雨有一个 n×n 的矩阵，起点在(1,1)，终点在(n,n)，只能向下或向右走，且每次只能走 1 步。矩阵上每个点都有一个点权 $a_{i,j}$ 。
求走到终点的路径有多少不同的点权和。

输入描述:
第一行，输入一个正整数 n 。
接下来 n+1 行，每行 n 个数，表示 $a_{i,j}$

输出描述:
共一行，输出有多少不同的点权和。

示例1
```
输入
2
1 5
2 4
输出
2
```
备注: $1 ≤n≤8, 0 ≤a_{i,j}≤50$

## 方法：遍历+递归
从 (1,1) 爆搜到(n,n)，把答案去一下重即可。

```python
n = int(input())
a = []
for _ in range(n):
    a.append(list(map(int, input().split())))

path = [] #不同的路径

def dp(num,i,j):
    num+=a[i][j]
    if i==n-1 and j==n-1 and (num not in path) :
        path.append(num)
        return 0
    if(i<n-1):
        dp(num,i+1,j);
    if(j<n-1):
        dp(num,i,j+1);
    
dp(0,0,0)
print(len(path))
```

# G-小石的图形
[牛客小白月赛16-G小石的图形](https://ac.nowcoder.com/acm/contest/949/G)

小石想在一面墙旁边建造一段长度为 n 的篱笆来围出一块地。

求最大的地的面积。

输入描述: 共一行，输入一个整数 n 。

输出描述:共一行，输出最大面积，保留 3 位小数。

示例1
```
输入1
输出0.159
```
备注:$1 ≤n≤10^3$

## 方法：数学几何
发现半圆时面积最大（显然）。 $n=πR, R=\frac{πR^2}{2} = \frac{n^2}{2π}$

面积 $n=πR, R=\frac{n}{π}$

```python
print("%.3f"%(int(input())**2/6.2831853))
```


# 参考
-   [牛客小白月赛16题解](https://ac.nowcoder.com/discuss/205975?type=101)