---
title: 动态规划 
date: 2019-04-05
categories: 
	    -   Algorithm
tags:  
        -   python
        -   LeetCode
        -   数据结构
        -   动态规划
mathjax: true
---
1.  递归 + 记忆化 ——> 递推（动态规划）
2.  状态的定义：数组 opt[n], dp[n], fib[n]
3.  状态转移方程：opt[n] = best_of(opt[n-1], opt[n-2], ...) 从前面的n-1个值得到最优的第n个值
4.  最优子结构

**学习内容：**

-   [LeetCode 509. 斐波那契数列](https://leetcode-cn.com/problems/fibonacci-number/)
-   LeetCode 70. 爬楼梯
-   0-1 背包问题
    -   自我实现
    -   Palindrome Partitioning II(132)
-   最小路径和（详细可看 Minimum Path Sum）
-   编程实现莱文斯坦最短编辑距离
-   编程实现查找两个字符串的最长公共子序列
-   编程实现一个数据序列的最长递增子序列
-   [LeetCode 10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

Minimum Path Sum（最小路径和）
英文版：https://leetcode.com/problems/minimum-path-sum/
中文版：https://leetcode-cn.com/problems/minimum-path-sum/
Coin Change （零钱兑换）
英文版：https://leetcode.com/problems/coin-change/
中文版：https://leetcode-cn.com/problems/coin-change/
Best Time to Buy and Sell Stock（买卖股票的最佳时机）
英文版：https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
中文版：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
Maximum Product Subarray（乘积最大子序列）
英文版：https://leetcode.com/problems/maximum-product-subarray/
中文版：https://leetcode-cn.com/problems/maximum-product-subarray/
Triangle（三角形最小路径和）
英文版：https://leetcode.com/problems/triangle/
中文版：https://leetcode-cn.com/problems/triangle/

<!-- more -->

# 斐波那契数列求值 
$f(n)=f(n-1)+f(n-2)$ 

斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。

[0,1,1,2,3,5,8,13,...]  给定`n`,计算 `f(N)`

## 方法：动态规划

-   递归 + 记忆化 -> 递推
-   递推公式：A[i] = A[i-1] + A[i-2]

```python
class Solution:
    def fib(self, N: int) -> int:
        if (N <= 1):
            return N
        A = [None]*(N+1)
        A[0] = 0
        A[1] = 1
        for i in range(2, N+1):
            A[i] = A[i-1] + A[i-2]
        return A[N]
```
更简洁的写法：
```python
class Solution:
    def fib(self, N: int) -> int:
        if (N <= 1):
            return N
        previous = 0
        current = 1
        for _ in range(N-1):
            previous, current = current, previous + current         
        return current
```

# LeetCode 70. 爬楼梯
[Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)


假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。


**示例 ：**
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

## 方法：动态规划
当有 $n$ 个台阶时，可供选择的走法可以分两类：1，先跨一阶再跨完剩下 $n-1$ 阶；2，先跨2阶再跨完剩下 $n-2$ 阶。所以 $n$ 阶的不同走法的数目是  $n-1$ 阶和 $n-2$ 阶的走法数的和。 这和斐波那契数列的规律相同，可以用这个思路。

动态规划来记录历史数据。

```python
class Solution:
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        prev, current = 0, 1
        for i in range(n):
            prev, current = current, prev + current
        return current
```

# LeetCode 10. 正则表达式匹配
给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。
```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。

说明:

-   s 可能为空，且只包含从 a-z 的小写字母。
-   p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
示例 2:
```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```
示例 3:
```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```
示例 4:
```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```
示例 5:
```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

## 方法：动态规划
动态方程 `dp[i][j]` 表示 $s$ 中 [0, i-1] 这前 $i$ 个字符与 $p$ 的 [0, j-1] 这前 $j$ 个字符组成的表示式是否匹配。

$$
dp[i+1][j+1] =
\begin{cases}
dp[i][j],  & \text{p[j] == '.'  or  (s[i] == p[j ])} 
\\[2ex]
dp[i+1][j-1]  , & \text{p[j] == '*' and p[j-1] 匹配0次}
\\[2ex]
dp[i+1][j], &\text{p[j] == '*' and p[j -1] 匹配1次}
\\[2ex]
dp[i][j+1],&\text{p[j] == '*' and p[j-1] 匹配超过1次}
\end{cases}
$$


```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        dp = [[False for _ in range(len(p)+1)] for _ in range(len(s)+1)]
        dp[0][0] = True
        for j in range(len(p)):
            if p[j]=='*': # 星号匹配空
                dp[0][j+1] = dp[0][j-1]
                
        for i in range(len(s)):
            for j in range(len(p)):
                if p[j] == s[i] or p[j]=='.':# 按位比较，相等
                    dp[i+1][j+1] = dp[i][j]
                if p[j] =='*':# 星号分两种情况
                    if p[j-1] != s[i] and p[j-1]!='.': #匹配0次
                        dp[i+1][j+1] = dp[i+1][j-1]
                    else: # 匹配多次、1次、0次
                        dp[i+1][j+1] = (dp[i][j+1] or dp[i+1][j] or dp[i+1][j-1])
        return dp[len(s)][len(p)]
```
