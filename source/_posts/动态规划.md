---
title: 动态规划 
date: 2019-04-05
categories: 
	    -   Algorithm
tags:  
        -   python
        -   LeetCode
        -   数据结构
        -   动态规划
mathjax: true
---
1.  递归 + 记忆化 ——> 递推（动态规划）
2.  状态的定义：数组 opt[n], dp[n], fib[n]
3.  状态转移方程：opt[n] = best_of(opt[n-1], opt[n-2], ...) 从前面的n-1个值得到最优的第n个值
4.  最优子结构

**学习内容：**

-   LeetCode 509. 斐波那契数列
-   LeetCode 70. 爬楼梯
-   0-1 背包问题
    -   自我实现
    -   Palindrome Partitioning II(132)
-   最小路径和（详细可看 Minimum Path Sum）
-   编程实现莱文斯坦最短编辑距离
-   编程实现查找两个字符串的最长公共子序列
-   编程实现一个数据序列的最长递增子序列

Regular Expression Matching（正则表达式匹配）
英文版：https://leetcode.com/problems/regular-expression-matching/
中文版：https://leetcode-cn.com/problems/regular-expression-matching/
Minimum Path Sum（最小路径和）
英文版：https://leetcode.com/problems/minimum-path-sum/
中文版：https://leetcode-cn.com/problems/minimum-path-sum/
Coin Change （零钱兑换）
英文版：https://leetcode.com/problems/coin-change/
中文版：https://leetcode-cn.com/problems/coin-change/
Best Time to Buy and Sell Stock（买卖股票的最佳时机）
英文版：https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
中文版：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
Maximum Product Subarray（乘积最大子序列）
英文版：https://leetcode.com/problems/maximum-product-subarray/
中文版：https://leetcode-cn.com/problems/maximum-product-subarray/
Triangle（三角形最小路径和）
英文版：https://leetcode.com/problems/triangle/
中文版：https://leetcode-cn.com/problems/triangle/

<!-- more -->

# 斐波那契数列求值 
[LeetCode 509. Fibonacci Number](https://leetcode-cn.com/problems/fibonacci-number/) $f(n)=f(n-1)+f(n-2)$ 

斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。

[0,1,1,2,3,5,8,13,...]  给定`n`,计算 `f(N)`

## 方法：动态规划

-   递归 + 记忆化 -> 递推
-   递推公式：A[i] = A[i-1] + A[i-2]

```python
class Solution:
    def fib(self, N: int) -> int:
        if (N <= 1):
            return N
        A = [None]*(N+1)
        A[0] = 0
        A[1] = 1
        for i in range(2, N+1):
            A[i] = A[i-1] + A[i-2]
        return A[N]
```
更简洁的写法：
```python
class Solution:
    def fib(self, N: int) -> int:
        if (N <= 1):
            return N
        previous = 0
        current = 1
        for _ in range(N-1):
            previous, current = current, previous + current         
        return current
```

# LeetCode 70. 爬楼梯
[Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)


假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。


**示例 ：**
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

## 方法：动态规划
当有 $n$ 个台阶时，可供选择的走法可以分两类：1，先跨一阶再跨完剩下 $n-1$ 阶；2，先跨2阶再跨完剩下 $n-2$ 阶。所以 $n$ 阶的不同走法的数目是  $n-1$ 阶和 $n-2$ 阶的走法数的和。 这和斐波那契数列的规律相同，可以用这个思路。

动态规划来记录历史数据。

```python
class Solution:
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        prev, current = 0, 1
        for i in range(n):
            prev, current = current, prev + current
        return current
```

